var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = UnivariateApprox","category":"page"},{"location":"#UnivariateApprox","page":"Home","title":"UnivariateApprox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for UnivariateApprox.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [UnivariateApprox]","category":"page"},{"location":"#UnivariateApprox.MollifiedBasis","page":"Home","title":"UnivariateApprox.MollifiedBasis","text":"MollifiedBasis(start, basis, moll)\n\nTake a basis and \"mollify\" it by a mollifier moll. Only affects basis functions of degree start or higher.\n\nOne example is Hermite Functions\n\nExample\n\njulia> basis = ProbabilistHermitePolynomial();\n\njulia> moll = SquaredExponential();\n\njulia> mollified_basis = MollifiedBasis(2, basis, moll); # starts mollifying at quadratic term\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateApprox.MonicOrthogonalPolynomial","page":"Home","title":"UnivariateApprox.MonicOrthogonalPolynomial","text":"Struct representing a monic orthogonal polynomial family via three-term recurrence relation:\n\np_k+1 = (x - a_k)p_k - b_kp_k-1\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateApprox.OrthogonalPolynomial","page":"Home","title":"UnivariateApprox.OrthogonalPolynomial","text":"Struct representing an orthogonal polynomial family via three-term recurrence relation:\n\nL_kp_k+1 = (m_kx - a_k)p_k - b_kp_k-1\n\n\n\n\n\n","category":"type"},{"location":"#UnivariateApprox.CreateQuadratureWeights","page":"Home","title":"UnivariateApprox.CreateQuadratureWeights","text":"CreateQuadratureWeights(pts, functions, true_integrals)\n\nSimple method to create quadrature weights to integrate functions correctly.\n\nArguments\n\npts::AbstractVector– vector of points\nfunctions(N, pt)– A function to evaluate the first N functions at 1d pt\ntrue_integrals(N)– A function to return the true integrals of rhe first N functions\nverbose::Bool– whether to be verbose\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateApprox.EvalDiff!","page":"Home","title":"UnivariateApprox.EvalDiff!","text":"EvalDiff!(eval_space::AbstractMatrix, diff_space::AbstractMatrix, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis and its derivative at x and store the results in eval_space and diff_space, respectively.\n\nExample\n\njulia> eval_space = zeros(3,2);\n\njulia> diff_space = zeros(3,2);\n\njulia> EvalDiff!(eval_space, diff_space, LegendrePolynomial(), [0.5, 0.75])\n\njulia> eval_space\n3×2 Matrix{Float64}:\n  1.0    1.0\n  0.5    0.75\n -0.125  0.34375\n\njulia> diff_space\n3×2 Matrix{Float64}:\n 0.0  0.0\n 1.0  1.0\n 1.5  2.25\n\nSee also: EvalDiff\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateApprox.EvalDiff-Union{Tuple{U}, Tuple{Int64, UnivariateApprox.UnivariateBasis, AbstractVector{U}}} where U","page":"Home","title":"UnivariateApprox.EvalDiff","text":"EvalDiff(max_degree::Int, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis and its derivative at x and return the result.\n\nExample\n\njulia> eval_space, diff_space = EvalDiff(2, LegendrePolynomial(), [0.5, 0.75]);\n\njulia> eval_space\n3×2 Matrix{Float64}:\n  1.0    1.0\n  0.5    0.75\n -0.125  0.34375\n\njulia> diff_space\n3×2 Matrix{Float64}:\n 0.0  0.0\n 1.0  1.0\n 1.5  2.25\n\nSee also: EvalDiff!\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.EvalDiff2!","page":"Home","title":"UnivariateApprox.EvalDiff2!","text":"EvalDiff2!(eval_space::AbstractMatrix, diff_space::AbstractMatrix, diff2_space::AbstractMatrix, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis and its first two derivatives at x and store the results in eval_space, diff_space and diff2_space, respectively.\n\nExample\n\njulia> eval_space = zeros(3,2);\n\njulia> diff_space = zeros(3,2);\n\njulia> diff2_space = zeros(3,2);\n\njulia> EvalDiff2!(eval_space, diff_space, diff2_space, LegendrePolynomial(), [0.5, 0.75])\n\njulia> eval_space\n3×2 Matrix{Float64}:\n  1.0    1.0\n  0.5    0.75\n -0.125  0.34375\n\njulia> diff_space\n3×2 Matrix{Float64}:\n 0.0  0.0\n 1.0  1.0\n 1.5  2.25\n\njulia> diff2_space\n3×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n 3.0  3.0\n\nSee also: EvalDiff2\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateApprox.EvalDiff2-Union{Tuple{U}, Tuple{Int64, UnivariateApprox.UnivariateBasis, AbstractVector{U}}} where U","page":"Home","title":"UnivariateApprox.EvalDiff2","text":"EvalDiff2(max_degree::Int, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis and its first two derivatives at x and return the results.\n\nExample\n\njulia> eval_space, diff_space, diff2_space = EvalDiff2(2, LegendrePolynomial(), [0.5, 0.75]);\n\njulia> eval_space\n3×2 Matrix{Float64}:\n  1.0    1.0\n  0.5    0.75\n -0.125  0.34375\n\njulia> diff_space\n3×2 Matrix{Float64}:\n 0.0  0.0\n 1.0  1.0\n 1.5  2.25\n\njulia> diff2_space\n3×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n 3.0  3.0\n\nSee also: EvalDiff2!\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.Evaluate!","page":"Home","title":"UnivariateApprox.Evaluate!","text":"Evaluate!(space::AbstractMatrix, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis at x and store the result in space.\n\nExample\n\njulia> space = zeros(3,2);\n\njulia> Evaluate!(space, LegendrePolynomial(), [0.5, 0.75])\n\njulia> space\n3×2 Matrix{Float64}:\n  1.0    1.0\n  0.5    0.75\n -0.125  0.34375\n\nSee also: Evaluate\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateApprox.Evaluate-Union{Tuple{U}, Tuple{Int64, UnivariateApprox.UnivariateBasis, AbstractVector{U}}} where U","page":"Home","title":"UnivariateApprox.Evaluate","text":"Evaluate(max_degree::Int, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis at x and return the result.\n\nExample\n\njulia> Evaluate(2, LegendrePolynomial(), [0.5, 0.75])\n3×2 Matrix{Float64}:\n  1.0    1.0\n  0.5    0.75\n -0.125  0.34375\n\nSee also: Evaluate!\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.EvaluateDegree!-Union{Tuple{U}, Tuple{AbstractVector{U}, Int64, UnivariateApprox.UnivariateBasis, AbstractVector{U}}} where U","page":"Home","title":"UnivariateApprox.EvaluateDegree!","text":"EvaluateDegree!(space::AbstractVector, degree::Int, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis of exactly degree at x and store the result in space.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.EvaluateDegree-Union{Tuple{U}, Tuple{Int64, UnivariateApprox.UnivariateBasis, AbstractVector{U}}} where U","page":"Home","title":"UnivariateApprox.EvaluateDegree","text":"EvaluateDegree(degree::Int, basis::UnivariateBasis, x::AbstractVector)\n\nEvaluate the univariate basis basis of exactly degree at x and return the result.\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.JacobiPolynomial-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"UnivariateApprox.JacobiPolynomial","text":"JacobiPolynomial(α,β)\n\nJacobi polynomials P^(α,β)_k, orthogonal on [-1,1] with weight (1-x)^α(1+x)^β\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.MonicJacobiPolynomial-Union{Tuple{T}, Tuple{T, T}} where T","page":"Home","title":"UnivariateApprox.MonicJacobiPolynomial","text":"MonicJacobiPolynomial(α,β)\n\nMonic Jacobi polynomials P^(α,β)_k, orthogonal on [-1,1] with weight (1-x)^α(1+x)^β\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.exactness","page":"Home","title":"UnivariateApprox.exactness","text":"exactness(rule, n)\n\nReturn the exactness of the quadrature rule rule for argument n.\n\nSome rules, e.g., Clenshaw-Curtis, have \"approximate\" exactness beyond the analytical exactness.\n\n\n\n\n\n","category":"function"},{"location":"#UnivariateApprox.gausslaguerre_lobatto-Tuple{Any}","page":"Home","title":"UnivariateApprox.gausslaguerre_lobatto","text":"gausslaguerre_lobatto(n)\n\nCreate an n-point quadrature rule to estimate the integral\n\nint_0^infty f(t)exp(-t) dt\n\nThis method guarantees the first evaluation will be at t_1=0 and is exact on polynomials up to degree 2n-2 (one degree of freedom is lost to fixing t_1).\n\n\n\n\n\n","category":"method"},{"location":"#UnivariateApprox.gausspatterson01-Tuple{Int64}","page":"Home","title":"UnivariateApprox.gausspatterson01","text":"gausspatterson01(n)\n\nNested gausspatterson rule to integrate over [0,1], adapted from John Burkardt's implementation.\n\nn must be 1, 3, 7, 15, 31, 63, 127, 255 or 511. Exact for polynomials up to degree 3*2^index - 1 for index > 1.\n\nSee here for more information\n\n\n\n\n\n","category":"method"}]
}
